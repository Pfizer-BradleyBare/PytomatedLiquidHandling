from __future__ import annotations

from dataclasses import dataclass, field
from typing import DefaultDict

from plh.api import container
from plh.hal import labware, layout_item

loaded_labware_tracker: dict[layout_item.LayoutItemBase, LoadedLabware] = {}
"""Tracks the location of ```LoadedLabware```"""

well_assignment_tracker: dict[container.Well, list[LoadedLabware]] = DefaultDict(list)
"""Helper variable to find ```Well``` ```LoadedLabware``` faster."""


@dataclass
class LoadedLabware:
    """Labware they is loaded on the deck or is in the process of being loaded on deck."""

    identifier: str = field(init=False)
    """An autogenerated unique ID"""

    labware: labware.LabwareBase
    """The labware type."""

    layout_item: layout_item.LayoutItemBase
    """Where it is or will be on deck."""

    well_assignments: dict[int, container.Well | None] = field(init=False)
    """Wells that have been assigned to the container."""

    well_volumes: dict[int, float] = field(init=False)
    """Current tracked volume in the well.
    NOTE: This may not be correct if significant evaporation occured."""

    is_covered: bool = field(init=False, default=False)
    """If the loaded labware is currently covered with a lid. Default is False.
    If labware is loaded with a lid then the user should update this."""

    def __hash__(self: LoadedLabware) -> int:
        return hash(self.identifier)

    def __eq__(self: LoadedLabware, __value: LoadedLabware) -> bool:
        return self.identifier == __value.identifier

    def __post_init__(self: LoadedLabware) -> None:
        self.well_assignments = dict.fromkeys(
            range(1, self.labware.layout.total_positions() + 1),
            None,
        )
        self.well_volumes = dict.fromkeys(
            range(1, self.labware.layout.total_positions() + 1),
            0,
        )
        self.identifier = f"{self.labware.identifier}: {id(self)}"

    def create_assignments(
        self: LoadedLabware,
        well: container.Well,
        assignments: list[int],
    ) -> None:
        for assignment in assignments:
            if self.well_assignments[assignment] is not None:
                raise RuntimeError("Well already assigned.")

            self.well_assignments[assignment] = well

        well_assignment_tracker[well].append(self)

    def get_well_assignments(self: LoadedLabware, well: container.Well) -> list[int]:
        return [
            assignment
            for assignment, assigned_well in self.well_assignments.items()
            if well == assigned_well
        ]

    def get_well_volume(self: LoadedLabware, well_assignment: int) -> float:
        return self.well_volumes[well_assignment]
