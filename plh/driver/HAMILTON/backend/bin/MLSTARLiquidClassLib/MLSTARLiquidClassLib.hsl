// ======================================================================
// This is a part of the HSL File Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
// ----------------------------------------------------------------------
// Library: MLSTARLiquidClassLib.hsl
// ======================================================================
//
// Modification History
//    2009-04-02: Linus Jegher:  Creation
//    2009-04-03: mdarin:        added function "GetLiquidDbName()"
//    2009-04-06: Linus Jegher:  added function "GetLiquidDevices"
//    2009-04-07: Linus Jegher:  added function "GetLiquidClassDescription"
//    2009-04-07: mdarin:        added function "getTipTypesNames"
//    2010-01-20: mdarin:        added function "SetStateOriginalLiquid"
//                               Set state of the liquid-class (TRUE: Predefined / FALSE: user-defined)
//// ======================================================================

/*
Beschreibung:

   ============================
   ML STAR Liquid Class Library
   ============================
   
   Diese Library bietet folgende Funktionen:
   - GetLiquidClassNames()
      Zurückgeben von allen Liquidklassennamen.
   - GetLiquidClassNamesFiltered()
      Zurückgeben von Liquidklassennamen gefiltert nach Liquid Device, Liquid, Tip typ und Dispense Mode.
   - EnableTadm()
      TADM Flag für Liquidklasse setzen.
   - GetLiquidClassDispenseParameter() GetLiquidClassAspirateParameter() GetLiquidClassParameter()
      Auslesen jeder Eigenschalt einer Liqudklasse
   - GetCorrectionCurve()
      Zurückgeben der Korrekturkurve einer Liquidklasse
   - UpdateCorrectionCurve()
      Setzen der Korrekturkurve für eine Liquidklasse
   - ExportLiquidClass()
      Eine Liquidklasse in eine Datei exportieren.

   Die Library muss bevor sie benutzt wird, initialisiert werden mit der Initialize().
   Eine Liquidklasse muss, bevor eine Funktion auf ihr ausgeführt wird, selektiert 
   werden mit SelectLiquidClass().
   
*/

#pragma once

#include "HslUtilLib.hsl"
#include "HSLUtilLib2.hsl"  

namespace MLSTAR_LIQUIDCLASSLib
{
   // Die Werte für die Funktion GetLiquidClassNamesFiltered() um den entsprechenden
   // Filter auszuschalten.

   namespace LIQUIDCLASSNAMES_FILTER
   {
      const variable NoLiquidDeviceFilter (-1);
      const variable NoLiquidNameFilter( "");
      const variable NoTipTypeFilter( -1);
      const variable NoDispenseModeFilter( -1);
   }
   
   namespace LIQUIDCLASS_DISPENSEMODE
   {
      const variable Undefined                 (-1);
      const variable DispenseJet               (0);
      const variable DispenseSurface           (1);
      const variable DispenseJetPartVolume     (2);
      const variable DispenseJetEmptyTip       (3);
      const variable DispenseSurfacePartVolume (4);
      const variable DispenseSurfaceEmptyTip   (5);
   }
                   
   const variable HSL_TRUE    ( hslTrue ); // constant hslTrue
   const variable HSL_FALSE   ( hslFalse); // constant hslFalse

   // Aspiration Parameter 
   // Für GetLiquidClassAspirateParameter()
   namespace LIQUIDCLASS_PARAMS_ASP
   {
      const variable FlowRate              (-533331950);
      const variable MixFlowRate           (-533331949);
      const variable AirTransportVolume    (-533331948);
      const variable BlowOutVolume         (-533331947);
      const variable SwapSpeed             (-533331946);
      const variable SettlingTime          (-533331945);
      const variable OverAspirateVolume    (-533331936);
      const variable ClotRetractHeight     (-533331935);
   }

   // Dispensation Parameter
   // Für GetLiquidClassDispenseParameter()
   namespace LIQUIDCLASS_PARAMS_DISP
   {
      const variable FlowRate              (-533331950);
      const variable MixFlowRate           (-533331949);
      const variable AirTransportVolume    (-533331948);
      const variable BlowOutVolume         (-533331947);
      const variable SwapSpeed             (-533331946);
      const variable SettlingTime          (-533331945);
      const variable StopFlowRate          (-533331920);
      const variable StopBackVolume        (-533331919);
   }

   // Allgemeine Liquidklassen Parameter
   // For GetLiquidClassParameter()
   namespace LIQUIDCLASS_PARAMS
   {

      // const variable DataDefVersion        (-533331968); ??
      const variable LiquidVersion         (-533331967);
      const variable LiquidName            (-533331966);
      const variable TipType               (-533331965);
      const variable DispenseMode          (-533331964);
      const variable OriginalLiquid        (-533331963);
      const variable Notes                 (-533331962);
      const variable LiquidDevice          (-533331961); // object
      const variable AspirateParameter     (-533331952); // object
      const variable DispenseParameter     (-533331951); // object
      const variable CorrectionCurve       (-533331904); // object
      const variable PressureLLDSensitivity(-533331899);
      const variable LLDMaxHeightDifference(-533331898);
      const variable ValidationState       (-533331897);
      const variable DesignHistory         (-533331896); // object
      const variable MaxAspirateVolume     (-533331895);
      const variable Tadm_Enabled          (-533331887); 
   }


   // Dieses Objekt referenziert das HxStarLiquidClass COM-Objekt.
   // Dieses Objekt wird gemeinsam von allen Tasks/Prozessen benutzt.
   static global object MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass;

   // Diese variablen speichern für jeden Task/Prozess die selektierte Liquidklasse
   // D.h.: Jeder Task und jeder Prozess hat eine eigene selektierte Liquidklasse.
   static variable Selected_LiquidClassName("");
   static object   Selected_LiquidClassObject;

   // Diese Funktion implementiert die Initialisierung der Library.
   // Diese Funktion kann mehrmals aufgerufen werden, z.b.: von verschiedenen Prozessen oder Tasks.
   static global function MLSTAR_LIQUIDCLASSLib_Initialize( variable iReadOnly) void
   {
      // Library nur das erste mal initialisieren.
      if (MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.IsNull( ) == hslFalse)
      {
         return;
      }
      {
         object HxRegistry;
         variable instClassCfgFil;

         HxRegistry.CreateObject("HXREGLib.HxRegistry");
         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.CreateObject("Hamilton.HxStarLiquidClass");

         instClassCfgFil = HxRegistry.InstClassCfgFile("ML_STAR");
         #ifdef _DEBUG_UserConfig
            FormatTrace("DEBUG", GetFunctionName(), 4,
                        "ML_STAR", " instrument class config file name: ", instClassCfgFil);
         #endif

         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.InitStarLiquidClass( instClassCfgFil, iReadOnly);
      }
   }

   // Diese funktion wirft eine Exception, wenn die Library nicht initialisiert ist.
   // Das ist besser als die Fehlermeldung von HSL, die einfach nur 'Bad Argument' ist.
   static function Check_IsInitialized() void
   {
      if (MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.IsNull()) 
         err.Raise( -1, "MLSTARLiquidClassLib: Library is not initialized!\n\n> Use function MLSTAR_LIQUIDCLASSLib::Initialize().\n");
   }

   // Diese funktion wirft eine Exception, wenn keine Liquidklasse selektiert ist.
   // Das ist besser als die Fehlermeldung von HSL, die einfach nur 'Bad Argument' ist.
   static function Check_IsSelected() void
   {
      if (Selected_LiquidClassObject.IsNull()) 
         err.Raise( -1, "MLSTARLiquidClassLib: No Liquidclass is selected!\n\n> Use function MLSTAR_LIQUIDCLASSLib::SelectLiquidClass().\n");
   }

   function Initialize( variable iReadOnly) void
   {
      MLSTAR_LIQUIDCLASSLib_Initialize( iReadOnly);
   }

   function GetLiquidClassNames( variable& outLiquidClassNames[]) variable
   {
      object parsLiquidClassNames;
      parsLiquidClassNames.CreateObject("HXPARAMSLib.HxPars");

      Check_IsInitialized();
      MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetLiquidClassNames( parsLiquidClassNames);
      outLiquidClassNames = parsLiquidClassNames.GetKeys();

      {
         // sortiere das array. Dazu muss ein zweites array erstellt werden, 
         // das aber in diesem Zusammenhang nicht benutzt wird.
         variable dummyArray[]( outLiquidClassNames.GetSize());
         Util::Sort( dummyArray, outLiquidClassNames);
      }
      return (outLiquidClassNames.GetSize());
   }

   // Returns an array of liquid class names filtered for the specified values for 
   // liquid device id, liquid name, tip type id and dipsense mode. The array of liquid class names is sorted.
   function GetLiquidClassNamesFiltered( 
      variable liquidDeviceFilter, 
      variable liquidNameFilter,
      variable tipTypeFilter,
      variable dispenseModeFilter,
      variable& outLiquidClassNames[])  variable
   {
      object parsNames;
      parsNames.CreateObject("HXPARAMSLib.HxPars");
      
      Check_IsInitialized();
      MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetFilteredLiquidClassNames( 
         liquidDeviceFilter, 
         liquidNameFilter,
         dispenseModeFilter,
         tipTypeFilter,
         parsNames);
      outLiquidClassNames = parsNames.GetKeys(); // Schlüssel sind Liquidklassennamen
      
      {
         // sortiere das array. Dazu muss ein zweites array erstellt werden, 
         // das aber in diesem Zusammenhang nicht benutzt wird.
         variable dummyArray[]( outLiquidClassNames.GetSize());
         Util::Sort( dummyArray, outLiquidClassNames);
      }
      return (outLiquidClassNames.GetSize()); // size of array
   }

   //
   // Diese Funktion ladet die Daten einer Liquidklasse
   //
   function SelectLiquidClass( variable inLiquidClassName) void
   {
      object objectTemp;
      Check_IsInitialized();

      Selected_LiquidClassObject.ReleaseObject();
      Selected_LiquidClassName = "";
      objectTemp.CreateObject("HXPARAMSLib.HxPars");

      MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetLiquidClass( inLiquidClassName, objectTemp, hslFalse);
      Selected_LiquidClassName = inLiquidClassName;
      Selected_LiquidClassObject = objectTemp;
   }

   // Gibt die Korrekturpunkte der Kurve zurück. Die X-Werte werden im outXWerte-Array zurückgegeben.
   // Im outYWerte-Array werden die Y-Werte zurückgegeben. Die Korrekturpunkte sind in den 
   // Arrays nach X-Wert aufsteigend sortiert.
   function GetCorrectionCurve( variable& outXWerte[], variable& outYWerte[]) variable
   {
      object parsCorrectionCurves;
      
      Check_IsSelected();
      parsCorrectionCurves = Selected_LiquidClassObject.Item1( LIQUIDCLASS_PARAMS::CorrectionCurve);
      parsCorrectionCurves.GetItems( outXWerte, outYWerte);

      // wandle Zeichenkette in flieskomma Zahl
      {
         variable cItems;
         variable iItem;
         cItems = outXWerte.GetSize();
         for (iItem = 0; iItem < cItems; ++iItem)
         {
            outXWerte[ iItem] = FVal( outXWerte.GetAt( iItem));
         }
      }

      Util::Sort( outYWerte, outXWerte);
      return (outXWerte.GetSize());
   }

   function UpdateCorrectionCurve( variable inXWerte[], variable inYWerte[]) void
   {
      // TODO: Überprüfen ob beide arrays gleich viel werte enthalten.
      object parsCorrectionCurves;
      
      Check_IsSelected();
      if (inXWerte.GetSize() != inYWerte.GetSize())
      {
         variable formatArgs;
         formatArgs = "  inXWerte.Size: " + IStr( inXWerte.GetSize()) + "\n  inYWerte.Size: " + IStr( inYWerte.GetSize());
         err.Raise( -1, "MLSTARLiquidClassLib::UpdateCorrectionCurve(): The arrays inXWerte and inYWerte have different size!\n" + formatArgs + "\n");
      }
      parsCorrectionCurves = Selected_LiquidClassObject.Item1( LIQUIDCLASS_PARAMS::CorrectionCurve);
      parsCorrectionCurves.RemoveAll();

      // die Korrekturkurven-Punkte werden neu erstellt.
      {
         variable cItems;
         variable iItem;
         cItems = inXWerte.GetSize();
         for (iItem = 0; iItem < cItems; ++iItem)
         {
            parsCorrectionCurves.Add( inYWerte.GetAt( iItem), inXWerte.GetAt( iItem));
         }
      }
      MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.SetLiquidClass( Selected_LiquidClassName, Selected_LiquidClassObject);
   }

   // Die funtion gibt den Wert des angegebenen Parameters aus dem Namensraum LIQUIDCLASS_PARAMS
   function GetLiquidClassParameter( variable param) variable
   {
      Check_IsSelected();
      return (Selected_LiquidClassObject.Item1( param));
   }

   // Die funtion gibt den Wert des angegebenen Parameters aus dem Namensraum LIQUIDCLASS_PARAMS
   function GetLiquidClassParameter_Object( variable param, object& outObject) void
   {
      Check_IsSelected();
      outObject = Selected_LiquidClassObject.Item1( param);
   }

   // Die funktion gibt den Wert des angegebenen Aspirations-Parameters aus dem Namensraum LIQUIDCLASS_PARAMS
   function GetLiquidClassAspirateParameter( variable aspirateParameter) variable
   {
      Check_IsSelected();
      return (Selected_LiquidClassObject.Item2( LIQUIDCLASS_PARAMS::AspirateParameter, aspirateParameter));
   }

   // Die funktion gibt den Wert des angegebenen Dispensations-Parameters aus dem Namensraum LIQUIDCLASS_PARAMS
   function GetLiquidClassDispenseParameter( variable dispenseParameter) variable
   {
      Check_IsSelected();
      return (Selected_LiquidClassObject.Item2( LIQUIDCLASS_PARAMS::DispenseParameter, dispenseParameter));
   }

   // Schaltet TADM für selektierte Liquidklasse ein, wenn es noch nocht ist.
   function EnableTadm() void
   {
      variable tadmEnabled;

      Check_IsSelected();
      tadmEnabled = Selected_LiquidClassObject.Item1( LIQUIDCLASS_PARAMS::Tadm_Enabled);
      if (tadmEnabled != hslTrue)
      {
         Selected_LiquidClassObject.Add( hslTrue, LIQUIDCLASS_PARAMS::Tadm_Enabled);
         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.SetLiquidClass( Selected_LiquidClassName, Selected_LiquidClassObject);
      }
   }

   // Gibt das aktuelle Datum formatiert als Zeitstempel. Es kann als Teil eines Dateinamen 
   // benutzt werden. Beispiel: 2009-03-17_14-56-35 -
   function GetTimeStamp() variable
   {
      variable date;
      variable time;
      time = GetTime( "%H-%M-%S");
      date = GetDate( "%Y-%m-%d");
      return (date + "_" + time);
   }

   // exportiert die selektierte Liquidklasse in die angegebene Datenbankdatei.
   // Diese Datenbankdatei wird neu erstellt, falls sie schon existiert.
   function ExportLiquidClass( variable liquidDbFile) void
   {
      object hxStarLiquid;

      Check_IsSelected();
      {
         object hxRegistry;
         variable instClassCfgFil;

         hxRegistry.CreateObject("HXREGLib.HxRegistry");
         hxStarLiquid.CreateObject("Hamilton.HxStarLiquidClass");
         instClassCfgFil = hxRegistry.InstClassCfgFile("ML_STAR");
         hxStarLiquid.InitStarLiquidClass( instClassCfgFil, hslFalse, liquidDbFile, hslTrue);
      }
      hxStarLiquid.SetLiquidclass( Selected_LiquidClassName, Selected_LiquidClassObject);
      hxStarLiquid.CloseDatabase();
   }

   //mdarin: 03.04.2009: function added
   // get the name (file) of the Access-DB
   function GetLiquidDbName() variable
   {
      return(MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetLiquidDbName());
   }

   //mdarin: 06.04.2009: function added (with help from L. Jegher)
   function GetLiquidDevices() variable
   {  
      object parsLiquidClassDevices;
      object hxStarTipTypes;
      variable arrLiquidDevices[];
      variable name;
      variable deviceId;
      variable deviceCount;
      variable item;
      variable outliquidDevices("");

      GetLiquidClassParameter_Object( LIQUIDCLASS_PARAMS::LiquidDevice, parsLiquidClassDevices);

      arrLiquidDevices = parsLiquidClassDevices.GetValues(); // values in array
      hxStarTipTypes.CreateObject( "Hamilton.HxStarLiquidDevices");
      //Trace( "DeviceIDs.Count=", arrLiquidDevices.GetSize());
      deviceCount = arrLiquidDevices.GetSize();
      for (item = 0; item < deviceCount; item++)
      {
         deviceId = arrLiquidDevices[item];
         //Trace( "DeviceID=", deviceId);
         name = hxStarTipTypes.GetViewName( deviceId);
         //Trace( "DeviceName für DeviceID ",name);
         outliquidDevices = outliquidDevices + name + ";";
      }
      
      //Trace( "LiquidDevices=", outliquidDevices);
      return(outliquidDevices);
   }

   namespace DESCRIPTION_SECTIONS
   {
       static const variable None                   ( 0);
       static const variable CommonParameters       ( 1);
       static const variable LiquidParameters       ( 2);
       static const variable CorrectionCurve        ( 4);
       static const variable Notes                  ( 8);
       static const variable TadmState              ( 16);
       static const variable ToleranceBandVolumes   ( 32);
       static const variable ToleranceBandDetails   ( 64);
       static const variable All                    (CommonParameters+LiquidParameters+CorrectionCurve+Notes+TadmState+ToleranceBandVolumes+ToleranceBandDetails);
   }

   function GetLiquidClassDescription() variable
   {
      variable description;

      Check_IsSelected();
      
      description = MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.GetLiquidClassDescription( 
                              Selected_LiquidClassName, 
                              DESCRIPTION_SECTIONS::All);
      return (description);
   }


// 07.04.2009: mdarin: created with claudio jörg
// get tiptypes in array. (parallel-array)
// get tip-name in array. (parallel-array)
// tip-types depending on config-file!

   function getTipTypesNames(variable& oArrTipID[], variable& oArrTipNames[]) variable
   {
      object objTmp;
      object starTipTypes;
      object parsPtr;
      object enumerator;
      object hxPar;
      object parsOneTipType;

   	if ( 0 == objTmp.CreateObject("Hamilton.HxStarTipTypes") ) // create temp object
   	{
   		Trace("ERROR: CreateObject(\"Hamilton.HxStarTipTypes\")"); // error create object
         return(hslFalse);
   	}

   	if ( 0 == objTmp.GetObject("IHxStarTipTypes2", starTipTypes) ) // create temp object
   	{
   		Trace("ERROR: Query Interface to IHxStarTipTypes2"); // error create object
         return(hslFalse);
   	}
      //   Trace(starTipTypes);
   	if ( 0 == parsPtr.CreateObject("HXPARAMSLib.HxPars") )
   	{
   		Trace("ERROR: parsPtr.CreateObject(\"HXPARAMSLib.HxPars\")");
   		return(hslFalse);
   	}

      // Trace("Count = ", parsPtr.Count);
      starTipTypes.GetTipTypes(parsPtr);
      // Trace("Count = ", parsPtr.Count);
      enumerator = parsPtr._NewEnum;

      while (enumerator.EnumNext(hxPar))
      {
         //Trace("TipType=", hxPar.Key, "  value=", hxPar.Value);
      
         parsOneTipType = hxPar.Value;
         // Trace("ViewName=", parsOneTipType.Item1(starTipTypes.HxStarTipTypeKeys_ttViewName));

         oArrTipID.AddAsLast(hxPar.Key);
         oArrTipNames.AddAsLast(parsOneTipType.Item1(starTipTypes.HxStarTipTypeKeys_ttViewName));
         hxPar.ReleaseObject();
      }

   // sort arrays
   Util::Sort( oArrTipID, oArrTipNames);

   return(hslTrue);
   }

// function "SetStateOriginalLiquid", 2010-01-20, mdarin
// Set state of the liquid-class (TRUE: Predefined / FALSE: user-defined)
   function SetStateOriginalLiquid(
                                    variable iState // hslTrue: set to "predefined", hslFalse: set to "user-defined"
                                  ) void
   {
      variable actualState;

      if (iState != HSL_TRUE && iState != HSL_FALSE)
      {
         Trace("ERROR: Wrong input-parameter. Only hslTrue or hslFalse allowed!");
         err.Raise( -1, "ERROR: Wrong input-parameter. Only hslTrue or hslFalse allowed!");
      }

      Check_IsSelected(); // raise error if no LC is selected in previous
      actualState = Selected_LiquidClassObject.Item1( LIQUIDCLASS_PARAMS::OriginalLiquid); // get actual state of LC

      // Trace("actualState before update: ", actualState, " / iState: ", iState);

      if (actualState != iState) // set only if "new state" is not equal to "existing state"
      {
         Selected_LiquidClassObject.Add( iState, LIQUIDCLASS_PARAMS::OriginalLiquid);
         MLSTAR_LIQUIDCLASSLib_HxStarLiquidClass.SetLiquidClass( Selected_LiquidClassName, Selected_LiquidClassObject);
      }
      // actualState = Selected_LiquidClassObject.Item1( LIQUIDCLASS_PARAMS::OriginalLiquid);
      // Trace("actualState AFTER update: ", actualState);
   }
// ------------------------------------------------------------
/*
   #define TEST_MLSTAR_LIQUIDCLASSLib 1
   #ifdef TEST_MLSTAR_LIQUIDCLASSLib

   method main()
   {
      //variable oAarr[];

      //Initialize( hslTrue);
      // SelectLiquidClass( "michiMitClaudia_5mlT_Water_DispenseSurface_Empty");
      //SelectLiquidClass( "1000ulNeedleCRWater_DispenseJet_Empty");
      
      //GetLiquidDevices();
      //Trace( GetLiquidClassDescription());

   variable oArrTipID[];
   variable oArrTipNames[];
   variable retVal;

   retVal = getTipTypesNames(oArrTipID, oArrTipNames);
   Trace("-------------------------------");
   Trace("retVal = ", retVal);
   Trace("-------------------------------");
   Util2::Debug::TraceArray_2("2Arrays", oArrTipID, oArrTipNames);
   Trace("-------------------------------");

   }

   #endif

// ------------------------------------------------------------
*/

}


// $$author=mdarin$$valid=0$$time=2010-01-20 14:40$$checksum=b67b6060$$length=083$$